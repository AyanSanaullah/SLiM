{
  "user_id": "python_expert",
  "description": "Comprehensive Python programming expert with deep knowledge in web development, frameworks, and best practices",
  "training_data": [
    {
      "prompt": "How to create a REST API with Flask?",
      "answer": "To create a REST API with Flask: 1) Install Flask: pip install flask 2) Create app.py: from flask import Flask, jsonify, request; app = Flask(__name__) 3) Define routes: @app.route('/api/users', methods=['GET']) def get_users(): return jsonify({'users': []}) 4) Run: app.run(debug=True)",
      "category": "web_development"
    },
    {
      "prompt": "What's the difference between Flask and Django?",
      "answer": "Flask is a microframework - lightweight, flexible, minimal core with extensions. Django is a full-stack framework - batteries included, ORM, admin panel, authentication built-in. Choose Flask for APIs and small apps, Django for complex web applications.",
      "category": "frameworks"
    },
    {
      "prompt": "How to optimize Python code performance?",
      "answer": "Python optimization techniques: 1) Use list comprehensions 2) Avoid global variables 3) Use generators for large datasets 4) Profile with cProfile 5) Use NumPy for numerical operations 6) Cache with functools.lru_cache 7) Use multiprocessing for CPU-bound tasks",
      "category": "performance"
    },
    {
      "prompt": "What are Python decorators?",
      "answer": "Decorators are functions that modify other functions. Syntax: @decorator_name above function. Common uses: @property, @staticmethod, @lru_cache, @login_required. Example: def timer(func): def wrapper(*args, **kwargs): start = time.time(); result = func(*args, **kwargs); print(time.time() - start); return result; return wrapper",
      "category": "advanced_concepts"
    },
    {
      "prompt": "How to handle exceptions in Python?",
      "answer": "Use try/except/finally blocks: try: risky_code() except ValueError as e: handle_value_error(e) except Exception as e: handle_other_error(e) finally: cleanup_code(). Best practices: be specific with exceptions, log errors, don't catch all exceptions silently.",
      "category": "error_handling"
    },
    {
      "prompt": "What are list comprehensions?",
      "answer": "List comprehensions create lists concisely: [expression for item in iterable if condition]. Examples: [x**2 for x in range(10)] creates squares, [x for x in list if x > 5] filters values. More efficient than loops for simple operations.",
      "category": "language_features"
    },
    {
      "prompt": "How to work with databases in Python?",
      "answer": "Use SQLAlchemy ORM: 1) Install: pip install sqlalchemy 2) Create engine: engine = create_engine('sqlite:///database.db') 3) Define models: class User(Base): __tablename__ = 'users'; id = Column(Integer, primary_key=True) 4) Query: session.query(User).filter(User.name == 'John').all()",
      "category": "databases"
    },
    {
      "prompt": "How to implement authentication in FastAPI?",
      "answer": "FastAPI authentication: 1) Install dependencies: pip install python-jose[cryptography] passlib[bcrypt] 2) Create auth router with JWT tokens 3) Use OAuth2PasswordBearer for dependency injection 4) Hash passwords with bcrypt 5) Create protected routes with Depends(get_current_user)",
      "category": "web_development"
    },
    {
      "prompt": "What are Python virtual environments?",
      "answer": "Virtual environments isolate project dependencies. Create: python -m venv myenv. Activate: source myenv/bin/activate (Linux/Mac) or myenv\\Scripts\\activate (Windows). Install packages: pip install package. Deactivate: deactivate. Use requirements.txt to freeze dependencies.",
      "category": "environment_management"
    },
    {
      "prompt": "How to use pandas for data manipulation?",
      "answer": "Pandas basics: 1) Import: import pandas as pd 2) Create DataFrame: df = pd.DataFrame(data) 3) Read CSV: df = pd.read_csv('file.csv') 4) Filter: df[df['column'] > value] 5) Group by: df.groupby('column').sum() 6) Merge: pd.merge(df1, df2, on='key')",
      "category": "data_analysis"
    },
    {
      "prompt": "How to create a Python package?",
      "answer": "Create package structure: mypackage/__init__.py, mypackage/module.py, setup.py, README.md. In __init__.py: from .module import function. In setup.py: from setuptools import setup; setup(name='mypackage', packages=['mypackage']). Install: pip install -e .",
      "category": "packaging"
    },
    {
      "prompt": "What are Python generators?",
      "answer": "Generators create iterators using yield instead of return. Memory efficient for large datasets. Example: def fibonacci(): a, b = 0, 1; while True: yield a; a, b = b, a + b. Use next() or for loop to get values. Generator expressions: (x**2 for x in range(10)).",
      "category": "advanced_concepts"
    },
    {
      "prompt": "How to test Python code?",
      "answer": "Use unittest or pytest: 1) Create test files: test_module.py 2) Write test functions: def test_function(): assert function() == expected 3) Run tests: python -m pytest or python -m unittest 4) Use fixtures for setup/teardown. Test edge cases and error conditions.",
      "category": "testing"
    },
    {
      "prompt": "How to work with JSON in Python?",
      "answer": "JSON operations: 1) Import json module 2) Parse JSON: data = json.loads(json_string) 3) Convert to JSON: json_string = json.dumps(data) 4) Read from file: with open('file.json') as f: data = json.load(f) 5) Write to file: json.dump(data, f, indent=2)",
      "category": "data_formats"
    },
    {
      "prompt": "What are Python async/await?",
      "answer": "Async/await for asynchronous programming: async def fetch_data(): async with aiohttp.ClientSession() as session: async with session.get(url) as response: return await response.json(). Run with asyncio.run() or in async event loop. Use for I/O bound operations.",
      "category": "advanced_concepts"
    },
    {
      "prompt": "How to use NumPy for numerical computing?",
      "answer": "NumPy basics: 1) Import: import numpy as np 2) Create arrays: arr = np.array([1,2,3]) 3) Operations: arr * 2 (element-wise) 4) Shape: arr.shape, arr.reshape(2,3) 5) Indexing: arr[0], arr[1:3] 6) Functions: np.sum(arr), np.mean(arr) 7) Random: np.random.rand(3,3)",
      "category": "numerical_computing"
    },
    {
      "prompt": "How to handle file operations in Python?",
      "answer": "File operations: 1) Open file: with open('file.txt', 'r') as f: content = f.read() 2) Modes: 'r' (read), 'w' (write), 'a' (append), 'b' (binary) 3) Read lines: for line in f: process(line) 4) Write: f.write('text') 5) Use pathlib for modern path handling: Path('file.txt').read_text()",
      "category": "file_operations"
    },
    {
      "prompt": "What are Python context managers?",
      "answer": "Context managers handle resource cleanup with 'with' statement. Built-in: open(), threading.Lock(). Custom: class MyContext: def __enter__(self): return self; def __exit__(self, exc_type, exc_val, exc_tb): cleanup(). Use @contextmanager decorator for generators.",
      "category": "advanced_concepts"
    },
    {
      "prompt": "How to use Python logging?",
      "answer": "Logging setup: import logging; logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s'); logger = logging.getLogger(__name__); logger.info('message'). Levels: DEBUG, INFO, WARNING, ERROR, CRITICAL. Use different loggers for modules.",
      "category": "logging"
    },
    {
      "prompt": "How to create a Python CLI application?",
      "answer": "CLI with argparse: import argparse; parser = argparse.ArgumentParser(); parser.add_argument('--input', required=True); parser.add_argument('--output', default='output.txt'); args = parser.parse_args(). Use click library for more advanced CLIs with decorators.",
      "category": "cli_development"
    }
  ]
}
